# Compiler and flags
CXX = g++
CXXFLAGS = -Wall -pg -fprofile-arcs -ftest-coverage -O2 # Enable gprof and coverage
LDFLAGS = -lgcov --coverage -pg # Linking flags for gcov and gprof

# Targets
TARGET = RandomGraph
OBJS = Graph.o RandomGraph.o

all: $(TARGET)

# Linking the objects to create the final executable
$(TARGET): $(OBJS)
	$(CXX) $(LDFLAGS) -o $(TARGET) $(OBJS)

# Compile Graph.cpp
Graph.o: Graph.cpp Graph.hpp
	$(CXX) $(CXXFLAGS) -c Graph.cpp

# Compile RandomGraph.cpp
RandomGraph.o: RandomGraph.cpp Graph.hpp
	$(CXX) $(CXXFLAGS) -c RandomGraph.cpp

# Compile tests.cpp with doctest
tests: Graph.o tests.o
	$(CXX) $(LDFLAGS) -o tests Graph.o tests.o

tests.o: tests.cpp Graph.hpp
	$(CXX) $(CXXFLAGS) -c tests.cpp

# Run the tests
run-tests: tests
	./tests

# Clean up the files generated by compilation, coverage, and profiling
clean:
	rm -f $(OBJS) $(TARGET) *.gcda *.gcno *.gcov gmon.out callgrind.out.* tests.o tests

# Run code coverage with gcov
coverage:
	./$(TARGET) -e 6 -v 4 -s 1234 # Example execution with random seed
	gcov Graph.cpp RandomGraph.cpp

# Run profiling with gprof
profile:
	./$(TARGET) -e 6 -v 4 -s 1234 # Example execution with random seed
	gprof ./$(TARGET) gmon.out > analysis.txt
	cat analysis.txt

# Run memory check with Valgrind
memcheck:
	valgrind --tool=memcheck --leak-check=full --track-origins=yes ./$(TARGET) -e 6 -v 4 -s 1234

# Run Valgrind callgrind tool for call graph generation
callgraph:
	valgrind --tool=callgrind ./$(TARGET) -e 6 -v 4 -s 1234
	callgrind_annotate callgrind.out.* > callgraph.txt
	cat callgraph.txt
